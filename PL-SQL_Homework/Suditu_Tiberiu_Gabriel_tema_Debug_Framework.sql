-- PART1 --

-- Tabel care stochează loguri de debug (mesaje, erori, variabile)
CREATE TABLE debug_log (
  log_id       NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,     -- ID unic, generat automat (Surrogate Key)
  log_time     TIMESTAMP DEFAULT SYSTIMESTAMP,                          -- Timpul când s-a scris logul
  module_name  VARCHAR2(100),                                           -- Numele modulului (procedură etc.)
  line_no      NUMBER,                                                  -- Linia codului (opțional)
  log_message  VARCHAR2(4000),                                          -- Mesajul logat (text liber)
  session_id   VARCHAR2(50) DEFAULT SYS_CONTEXT('USERENV', 'SESSIONID') -- ID-ul sesiunii Oracle
);


-- Pachet pentru controlul și scrierea de mesaje de debug
-- SPEC --
CREATE OR REPLACE PACKAGE debug_utils IS
  g_debug_mode BOOLEAN := FALSE;  -- Flag global: TRUE = activat, FALSE = dezactivat

  -- Activează modul de debug
  PROCEDURE enable_debug;

  -- Dezactivează modul de debug
  PROCEDURE disable_debug;

  -- Logează un mesaj text simplu
  PROCEDURE log_msg(p_message VARCHAR2);

  -- Logează o variabilă (nume și valoare)
  PROCEDURE log_variable(p_name VARCHAR2, p_value VARCHAR2);

  -- Logează o eroare dintr-o procedură specificată
  PROCEDURE log_error(p_proc VARCHAR2, p_err VARCHAR2);
END debug_utils;


-- BODY --
CREATE OR REPLACE PACKAGE BODY debug_utils IS

  -- Activează flag-ul de debug
  PROCEDURE enable_debug IS
  BEGIN
    g_debug_mode := TRUE;
  END;

  -- Dezactivează flag-ul de debug
  PROCEDURE disable_debug IS
  BEGIN
    g_debug_mode := FALSE;
  END;

  -- Scrie un mesaj în log, dacă debugul e activ
  PROCEDURE log_msg(p_message VARCHAR2) IS
  BEGIN
    IF g_debug_mode THEN
      INSERT INTO debug_log(module_name, line_no, log_message)
      VALUES ('anonymous', NULL, p_message); -- Folosim 'anonymous' dacă nu avem nume de procedură
    END IF;
  END;

  -- Scrie o variabilă și valoarea ei în log
  PROCEDURE log_variable(p_name VARCHAR2, p_value VARCHAR2) IS
  BEGIN
    IF g_debug_mode THEN
      INSERT INTO debug_log(module_name, line_no, log_message)
      VALUES ('anonymous', NULL, p_name || ' = ' || p_value);
    END IF;
  END;

  -- Scrie un mesaj de eroare pentru o procedură specificată
  PROCEDURE log_error(p_proc VARCHAR2, p_err VARCHAR2) IS
  BEGIN
    IF g_debug_mode THEN
      INSERT INTO debug_log(module_name, line_no, log_message)
      VALUES (p_proc, NULL, 'ERROR: ' || p_err);
    END IF;
  END;

END debug_utils;


-- Exemplu de utilizare / Verificare utilizare --
SET SERVEROUTPUT ON;

BEGIN
  debug_utils.enable_debug;

  debug_utils.log_msg('Test mesaj');                          -- mesaj simplu
  debug_utils.log_variable('v_salariu', '4500');              -- variabilă logată
  debug_utils.log_error('test_proc', 'Valoare nevalidă');     -- eroare simulată

  debug_utils.disable_debug;
END;

DELETE FROM DEBUG_LOG;


-- PART2 --

-- Procedură care ajustează salariile angajaților în funcție de comision
CREATE OR REPLACE PROCEDURE adjust_salaries_by_commission IS

  -- Cursor care selectează toți angajații, blocând rândurile pentru update
  CURSOR emp_cursor IS
    SELECT employee_id, salary, commission_pct
    FROM employees
    FOR UPDATE;

  -- Variabilă pentru calculul noului salariu
  v_new_salary employees.salary%TYPE;

BEGIN
  -- Activăm modul de debug
  debug_utils.enable_debug;
  debug_utils.log_msg('Încep procesul de ajustare a salariilor');

  -- Parcurgem fiecare angajat
  FOR emp IN emp_cursor LOOP

    -- Dacă are commission_pct, se aplică procentual
    IF emp.commission_pct IS NOT NULL THEN
      v_new_salary := emp.salary + emp.salary * emp.commission_pct;
      debug_utils.log_msg('Aplica comision pentru angajat ' || emp.employee_id);
    
    -- Dacă NU are comision, aplicăm o majorare de 2%
    ELSE
      v_new_salary := emp.salary + emp.salary * 0.02;
      debug_utils.log_msg('Aplica majorare fixă 2% pentru angajat ' || emp.employee_id);
    END IF;

    -- Logăm variabilele relevante
    debug_utils.log_variable('employee_id', TO_CHAR(emp.employee_id));
    debug_utils.log_variable('old_salary', TO_CHAR(emp.salary));
    debug_utils.log_variable('new_salary', TO_CHAR(v_new_salary));

    -- Actualizăm salariul pentru rândul curent
    UPDATE employees
    SET salary = v_new_salary
    WHERE CURRENT OF emp_cursor;

  END LOOP;

  -- Închidem sesiunea de debug
  debug_utils.log_msg('Ajustarea salariilor s-a încheiat');
  debug_utils.disable_debug;

-- În caz de eroare, logăm mesajul și facem rollback
EXCEPTION
  WHEN OTHERS THEN
    debug_utils.log_error('adjust_salaries_by_commission', SQLERRM);
    ROLLBACK;
END;


-- Apel procedura
BEGIN
  adjust_salaries_by_commission;
END;


-- Verificare tabel in urma aplicarii procedurii
SELECT * FROM DEBUG_LOG;

