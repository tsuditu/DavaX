-- •	sa existe cate un exemplu din toate constrainturile prezentate --
-- Cream un tabel de Departamente cu:
-- - id generat automat (surrogate key)
-- - nume obligatoriu (NOT NULL)
-- - cod unic (UNIQUE)
CREATE TABLE Tema_Departament (
    id_departament NUMBER GENERATED ALWAYS AS IDENTITY
        (START WITH 10 INCREMENT BY 10) PRIMARY KEY, -- Sistemul obligatoriu genereaza valoarea; orice valoare data manual → eroare / GENERATED BY DEFAULT AS IDENTITY ->	Sistemul genereaza automat, dar poti da tu o valoare daca vrei
    nume VARCHAR2(100) NOT NULL,                     -- Valoare obligatorie
    cod_unic VARCHAR2(10) UNIQUE                     -- Valoare unica
);

-- Cream un tabel de Angajati cu mai multe constrainturi:
-- - PRIMARY KEY pe id
-- - NOT NULL pe nume
-- - UNIQUE pe email
-- - CHECK pe salariu si gen (simulare ENUM)
-- - DEFAULT pe status
-- - FOREIGN KEY spre Tema_Departament
CREATE TABLE Tema_Angajat (
    id_angajat NUMBER PRIMARY KEY,                           -- PRIMARY KEY
    nume VARCHAR2(50) NOT NULL,                              -- NOT NULL
    email VARCHAR2(100) UNIQUE,                              -- UNIQUE
    salariu NUMBER(8,2) CHECK (salariu >= 2500),             -- CHECK
    gen VARCHAR2(10) CHECK (gen IN ('Masculin', 'Feminin', 'Altul')), -- ENUM simulat
    status VARCHAR2(10) DEFAULT 'activ',                     -- DEFAULT
    id_departament NUMBER,                                   -- va fi FOREIGN KEY
    CONSTRAINT fk_angajat_dep FOREIGN KEY (id_departament)
        REFERENCES Tema_Departament(id_departament)
);

-- Inseram 5 departamente in Tema_Departament
INSERT INTO Tema_Departament (nume, cod_unic) VALUES ('IT', 'IT01');
INSERT INTO Tema_Departament (nume, cod_unic) VALUES ('HR', 'HR02');
INSERT INTO Tema_Departament (nume, cod_unic) VALUES ('Finante', 'FIN03');
INSERT INTO Tema_Departament (nume, cod_unic) VALUES ('Vanzari', 'VAN04');
INSERT INTO Tema_Departament (nume, cod_unic) VALUES ('Marketing', 'MKT05');

-- Inseram 5 angajati, fiecare asignat unui departament
INSERT INTO Tema_Angajat (id_angajat, nume, email, salariu, gen, status, id_departament)
VALUES (1, 'Ana Popescu', 'ana.popescu@endava.com', 3500, 'Feminin', 'activ', 10);

INSERT INTO Tema_Angajat (id_angajat, nume, email, salariu, gen, status, id_departament)
VALUES (2, 'Mihai Ionescu', 'mihai.ionescu@endava.com', 4200, 'Masculin', 'activ', 20);

INSERT INTO Tema_Angajat (id_angajat, nume, email, salariu, gen, status, id_departament)
VALUES (3, 'Elena Stoica', 'elena.stoica@endava.com', 2700, 'Feminin', 'activ', 30);

INSERT INTO Tema_Angajat (id_angajat, nume, email, salariu, gen, status, id_departament)
VALUES (4, 'Alex Dima', 'alex.dima@endava.com', 5000, 'Masculin', 'activ', 40);

INSERT INTO Tema_Angajat (id_angajat, nume, email, salariu, gen, status, id_departament)
VALUES (5, 'Ioana Marinescu', 'ioana.marinescu@endava.com', 2900, 'Altul', 'activ', 50);


-- •	sa contina o coloana sa contina date semistructurate  (json/xml) --
-- Adaugam o coloana CLOB in tabela Tema_Angajat in care salvam JSON si validam formatul
ALTER TABLE Tema_Angajat
ADD (
    profil_json CLOB
        CONSTRAINT chk_profil_json CHECK (profil_json IS JSON) -- Validare JSON
);

-- Inseram o valoare de tip JSON pentru angajatul cu ID 1 --
UPDATE Tema_Angajat
SET profil_json = '{
    "hobby": "drumeții",
    "certificari": ["OCP", "Scrum Master"],
    "preferinte": {
        "program": "08:00-16:00",
        "lucru_remote": true
    }
}'
WHERE id_angajat = 1;

-- Selectam informatii extrase din JSON (hobby si program preferat)
SELECT nume,
       json_value(profil_json, '$.hobby') AS hobby,
       json_value(profil_json, '$.preferinte.program') AS program
FROM Tema_Angajat
WHERE profil_json IS NOT NULL;


-- • sa existe si alte campuri indexate afara de FK/PK --
-- Cream index pe nume pentru cautari rapide dupa nume
CREATE INDEX idx_angajat_nume ON Tema_Angajat(nume);

-- Cream index pe salariu pentru sortari si filtrari
CREATE INDEX idx_angajat_salariu ON Tema_Angajat(salariu);

-- Cream index pe gen pentru filtrari statistice
CREATE INDEX idx_angajat_gen ON Tema_Angajat(gen);

-- Selectam angajatii cu salariu peste 4000, sortati descrescator
-- Aceasta interogare foloseste indexul pe salariu, pentru o cautare rapida
SELECT 
    id_angajat,
    nume,
    salariu
FROM 
    Tema_Angajat
WHERE 
    salariu > 4000
ORDER BY 
    salariu DESC;


-- • sa contina cel putin un view --
-- Cream un VIEW care afiseaza angajatii activi si numele departamentului lor
CREATE VIEW VW_Angajati_Activi AS
SELECT 
    a.nume AS nume_angajat,            -- Numele angajatului
    a.email,                           -- Emailul angajatului
    a.salariu,                         -- Salariul
    d.nume AS nume_departament         -- Numele departamentului, preluat din Tema_Departament
FROM 
    Tema_Angajat a                     -- Tabelul angajatilor (alias: a)
JOIN 
    Tema_Departament d                 -- Tabelul departamentelor (alias: d)
ON 
    a.id_departament = d.id_departament -- Legam angajatul de departamentul lui pe baza cheii straine (id_departament)
                                        -- Folosim JOIN ca sa putem afisa informatii din ambele tabele (Angajat + Departament)
WHERE 
    a.status = 'activ';                -- Luam doar angajatii activi

-- Interogare View --
SELECT 
    * 
FROM 
    VW_Angajati_Activi;


-- • sa contina cel putin un materialized view --
-- Cream un MATERIALIZED VIEW care preagrega datele: 
-- vrem sa vedem salariul mediu pe departament, doar pentru angajatii activi
-- View-ul se bazeaza pe join intre Tema_Angajat si Tema_Departament
-- View-ul este salvat fizic si poate fi folosit in raportari pentru performanta crescuta

CREATE MATERIALIZED VIEW MV_Salariu_Mediu_Departament
BUILD IMMEDIATE                             -- construieste imediat view-ul (nu in background)
REFRESH ON DEMAND                           -- se actualizeaza manual, nu automat (ON COMMIT - care nu merge cu GROUP BY, JOIN etc.)
AS
SELECT 
    d.nume AS nume_departament,            -- numele departamentului
    ROUND(AVG(a.salariu), 2) AS salariu_mediu -- salariul mediu al angajatilor activi, rotunjit
FROM 
    Tema_Angajat a
JOIN 
    Tema_Departament d ON a.id_departament = d.id_departament
WHERE 
    a.status = 'activ'                     -- consideram doar angajatii activi
GROUP BY 
    d.nume;                                -- agregam pe fiecare departament

-- Interogare pe materialized view pentru a afisa salariul mediu pe departamente
SELECT 
    * 
FROM 
    MV_Salariu_Mediu_Departament;

-- REFRESH MANUAL PENTRU MATERIALIZED VIEW cand modificam tabela principala --
BEGIN
    DBMS_MVIEW.REFRESH('MV_Salariu_Mediu_Departament');
END;
/


-- • sa existe cel putin un select asupra structurii in care se foloseste group by --
-- Adaugam 2 angajati noi in departamentul IT (id_departament = 10)
INSERT INTO Tema_Angajat (id_angajat, nume, email, salariu, gen, status, id_departament)
VALUES (6, 'Radu Serban', 'radu.serban@endava.com', 3100, 'Masculin', 'activ', 10);

INSERT INTO Tema_Angajat (id_angajat, nume, email, salariu, gen, status, id_departament)
VALUES (7, 'Corina Vlad', 'corina.vlad@endava.com', 3300, 'Feminin', 'activ', 10);

-- Adaugam 1 angajat nou in departamentul HR (id_departament = 20)
INSERT INTO Tema_Angajat (id_angajat, nume, email, salariu, gen, status, id_departament)
VALUES (8, 'Bogdan Enache', 'bogdan.enache@endava.com', 3600, 'Masculin', 'activ', 20);

-- Adaugam 2 angajati noi in departamentul Finante (id_departament = 30)
INSERT INTO Tema_Angajat (id_angajat, nume, email, salariu, gen, status, id_departament)
VALUES (9, 'Andreea Dobre', 'andreea.dobre@endava.com', 2800, 'Feminin', 'activ', 30);

INSERT INTO Tema_Angajat (id_angajat, nume, email, salariu, gen, status, id_departament)
VALUES (10, 'Sorin Maxim', 'sorin.maxim@endava.com', 3000, 'Masculin', 'activ', 30);


-- Selectam numarul de angajati activi din fiecare departament
-- Grupam datele dupa numele departamentului
SELECT 
    d.nume AS nume_departament,           -- numele departamentului
    COUNT(a.id_angajat) AS nr_angajati    -- numarul total de angajati activi din acel departament
                                          -- Functia COUNT() numara randurile, adica angajatii in acest caz
FROM 
    Tema_Angajat a
JOIN 
    Tema_Departament d ON a.id_departament = d.id_departament -- legam angajatul de departamentul lui
WHERE 
    a.status = 'activ'                    -- luam in considerare doar angajatii activi
GROUP BY 
    d.nume                                -- grupam dupa numele departamentului
ORDER BY 
    nr_angajati DESC;                     -- optional: sortam descrescator dupa numarul de angajati


-- • sa existe cel putin un select asupra structurii cu LEFT JOIN --

-- Dezactivam temporar constraintul FOREIGN KEY pentru a permite inserarea unui angajat
-- cu un id_departament care NU exista in Tema_Departament (ex: 999)
-- Acest lucru este facut DOAR in scop demonstrativ, pentru a testa cum functioneaza LEFT JOIN
ALTER TABLE Tema_Angajat DISABLE CONSTRAINT fk_angajat_dep;

-- Inseram un angajat care are departament invalid (id_departament = 999)
-- Acesta NU are corespondenta in Tema_Departament
INSERT INTO Tema_Angajat (id_angajat, nume, email, salariu, gen, status, id_departament)
VALUES (11, 'Vlad Popa', 'vlad.popa@endava.com', 3400, 'Masculin', 'activ', 999);

-- Reactivam constraintul FOREIGN KEY dupa ce am facut inserarea pentru test
-- Astfel, integritatea referentiala este restabilita pentru restul operatiilor
ALTER TABLE Tema_Angajat ENABLE CONSTRAINT fk_angajat_dep;

-- Inseram un alt angajat fara niciun departament (id_departament = NULL)
-- Este o situatie realista si valida, utila pentru a testa LEFT JOIN
INSERT INTO Tema_Angajat (id_angajat, nume, email, salariu, gen, status, id_departament)
VALUES (12, 'Alina Tudor', 'alina.tudor@endava.com', 3600, 'Feminin', 'activ', NULL);

-- Interogare cu LEFT JOIN pentru a afisa toti angajatii, inclusiv cei care nu au departament valid
-- Departamentele care nu au corespondenta vor aparea cu NULL in coloana nume_departament
SELECT 
    a.nume AS nume_angajat,            -- numele angajatului
    d.nume AS nume_departament         -- numele departamentului, daca exista (altfel NULL)
FROM 
    Tema_Angajat a                     -- tabela din stanga (pastreaza toate randurile)
LEFT JOIN 
    Tema_Departament d ON a.id_departament = d.id_departament -- legam pe baza FK
ORDER BY 
    nume_angajat;                      -- sortam alfabetic dupa numele angajatului


-- • sa existe cel putin un select asupra structurii cu o functie analitica, alta decat row_number --
-- Selectam angajatii activi si aplicam functia analitica RANK()
-- RANK() clasifica angajatii in fiecare departament dupa salariu descrescator
-- Angajatii cu acelasi salariu vor avea acelasi rank
-- Daca exista egalitati, numerotarea va sari (ex: 1, 2, 2, 4)

SELECT 
    a.nume AS nume_angajat,                -- numele angajatului
    d.nume AS nume_departament,            -- numele departamentului
    a.salariu,                             -- salariul angajatului
    RANK() OVER (
        PARTITION BY d.id_departament      -- grupam angajatii pe departament
        ORDER BY a.salariu DESC            -- ordonam descrescator dupa salariu
    ) AS pozitie_salariu                   -- rank-ul in functie de salariu in acel departament
FROM 
    Tema_Angajat a
JOIN 
    Tema_Departament d ON a.id_departament = d.id_departament
WHERE 
    a.status = 'activ'                     -- luam in considerare doar angajatii activi
ORDER BY 
    d.nume, pozitie_salariu;


CREATE TABLE Tema_Pontaj (
    id_pontaj NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    id_angajat NUMBER NOT NULL,
    data_pontaj DATE NOT NULL,
    ore_lucrate NUMBER(4,2) CHECK (ore_lucrate BETWEEN 0 AND 24),
    activitate VARCHAR2(100),
    CONSTRAINT fk_pontaj_angajat FOREIGN KEY (id_angajat) REFERENCES Tema_Angajat(id_angajat)
);

-- Ana Popescu
INSERT INTO Tema_Pontaj (id_angajat, data_pontaj, ore_lucrate, activitate)
VALUES (1, DATE '2025-06-01', 8, 'Analyse Requirements');

INSERT INTO Tema_Pontaj (id_angajat, data_pontaj, ore_lucrate, activitate)
VALUES (1, DATE '2025-06-02', 6.5, 'Project Arhitecture');

-- Mihai Ionescu
INSERT INTO Tema_Pontaj (id_angajat, data_pontaj, ore_lucrate, activitate)
VALUES (2, DATE '2025-06-01', 7, 'Code Enhancements');

-- Elena Stoica
INSERT INTO Tema_Pontaj (id_angajat, data_pontaj, ore_lucrate, activitate)
VALUES (3, DATE '2025-06-01', 8, 'Application Testing');

-- Alex Dima
INSERT INTO Tema_Pontaj (id_angajat, data_pontaj, ore_lucrate, activitate)
VALUES (4, DATE '2025-06-01', 5, 'Documentation');

-- Ioana Marinescu
INSERT INTO Tema_Pontaj (id_angajat, data_pontaj, ore_lucrate, activitate)
VALUES (5, DATE '2025-06-01', 8, 'Client Support');


-- Afisam totalul de ore lucrate de fiecare angajat
SELECT 
    a.nume,
    SUM(p.ore_lucrate) AS total_ore
FROM 
    Tema_Pontaj p
JOIN 
    Tema_Angajat a ON a.id_angajat = p.id_angajat
GROUP BY 
    a.nume
ORDER BY 
    total_ore DESC;


-- Afisam orele lucrate pe zi si rank-ul in functie de cine a lucrat cel mai mult intr-o zi
SELECT 
    a.nume,
    p.data_pontaj,
    p.ore_lucrate,
    RANK() OVER (PARTITION BY p.data_pontaj ORDER BY p.ore_lucrate DESC) AS rank_zi
FROM 
    Tema_Pontaj p
JOIN 
    Tema_Angajat a ON a.id_angajat = p.id_angajat
ORDER BY 
    p.data_pontaj, rank_zi;


-- Afisam toti angajatii, inclusiv cei care nu au pontaj (sunt LEFT JOIN)
SELECT 
    a.nume,
    p.data_pontaj,
    p.ore_lucrate,
    p.activitate
FROM 
    Tema_Angajat a
LEFT JOIN 
    Tema_Pontaj p ON a.id_angajat = p.id_angajat
ORDER BY 
    a.nume, p.data_pontaj;

-- COMMIT finalizeaza tranzactiile si salveaza modificarile permanent in baza de date
-- Este folosit in special dupa operatii care MODIFICA datele:
--    - INSERT (adaugare de date)
--    - UPDATE (modificare de date existente)
--    - DELETE (stergere de date)
-- COMMIT face ca aceste modificari sa fie vizibile pentru toti utilizatorii bazei de date

-- NU este necesar dupa comenzi care doar CREEAZA structura bazei (DDL):
--    - CREATE TABLE, CREATE VIEW, CREATE INDEX etc.
-- Acestea se finalizeaza automat (Oracle face implicit COMMIT)

-- In acest script, COMMIT salveaza:
--    - Angajatii adaugati cu INSERT
--    - Update-ul profilului JSON
--    - Modificarile pentru testul cu LEFT JOIN
--    - Orice alte modificari de date efectuate

COMMIT;
